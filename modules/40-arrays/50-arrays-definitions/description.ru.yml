---
name: Способы определения массивов
theory: |

  В Ruby необычно много способов создания массивов. Они помогают сделать определение короче, и достаточно часто используются на практике. Особенно любит их линтер Rubocop.

  ```ruby
  # Обычное определение
  ['apple', 'orange', 'melon']

  # Сокращенное
  %w[apple orange melon]
  ```

  `%w` позволяет задавать массив перечислением без использования дополнительных символов. Даже в примере выше видно, насколько код получается короче и даже читаемее. Единственное ограничение такого способа – наличие пробелов в значениях. Каждый пробел считается разделителем значений:

  ```ruby
  %w[first second value third]
  # ["first", "second", "value", "third"]
  ```

  Технически, слова можно экранировать, но так обычно не делают из-за резкого ухудшения читаемости:

  ```ruby
  %w[first second\ value third]
  # ["first", "second value", "third"]
  ```

  Похожим способом создается массив символов, только вместо `%w` используется `%i`:

  ```ruby
  %i[apple orange melon] # [:apple, :orange, :melon]
  ```

  Так же массивы можно создавать из диапазонов или итераторов:

  ```ruby
  (1..5).to_a # [1, 2, 3, 4, 5]
  1.upto(5).to_a # [1, 2, 3, 4, 5]
  ```

  В некоторых достаточно редких случаях можно воспользоваться динамическим созданием значений. Для этого используется конструктор Array и блок, вычисляющий значение для нужного индекса:

  ```ruby
  Array.new(5) { |i| i ** 2 }
  # [0, 1, 4, 9, 16]
  ```

instructions: |

  Реализуйте функцию `valid_date?`, которая проверяет переданную дату на допустимость по двум критериям:

  * Месяц находится между 1 и 12
  * День находится между 1 и 31

  Дата поступает на вход всегда в формате: *dd-mm-yyyy*. Не используйте функции для работы с датами, реализуйте все с помощью обычных типов данных.

  ```ruby
  valid_date?('11-11-2011') # true
  valid_date?('13-11-2011') # true
  valid_date?('11-13-2011') # false
  valid_date?('55-11-2011') # false
  ```

tips: []
